<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>必包</title>
</head>

<body>
    <script type="text/javascript">
        // 1
        // var a = 25;
        // (function(){
        //     alert(a);// undefined
        //     var a = 30; 
        // })();

        // 2
        // this.a = 20;
        // var test = {
        //     init: () => {
        //         console.log(this.a);

        //         function go() {
        //             this.a = 60;
        //             console.log(this.a);
        //         }
        //         go.prototype.a = 50;
        //         return go;
        //     }
        // }
        // var p = test.init();
        // p();
        // new(test.init());

        // 3
        // this.a = 20;
        // var p = {
        //     a: 30,
        //     test:function(){
        //         //alert(this.a);
        //         function s(){
        //             alert(this.a);
        //         }
        //         this.s();
        //     } 
        // }
        // // js规则： 谁调用谁就是this
        // p.test();
        //console.log(p.s());
        // 必包
        // function f1(){
        //     var N = 0;
        //     function f2(){
        //         N+=1;
        //         console.log(N);
        //     }
        //     return f2;
        // }
        // var result = f1();
        // result();
        // result();
        // result();
        // result = null;

        // 类
        // var Car = function(color){
        //     // constructor ==  Car 在js中构造函数和初始化这个类就是一个东西ß
        //     this.color = color;
        //     console.log("1111");    
        // }
        // // 原型链，一般将公用的方法放在原型链上，减少构建方法的次数
        // Car.prototype.sail = function(){
        //     console.log(this.color+"卖了100W");
        // }
        // // var s = new Car("red"); // 在这里经过new关键字，那么this指的就是 new出来的对象
        // // console.log(s.sail());

        // var BWM = function(color){
        //     // 继承
        //     Car.call(this,color);
        // }
        // // 按引用传递
        // // 1.拿到父类原型链上的方法
        // // 2.不能上构造函数执行两次
        // // 3.引用的原型不能按值引用
        // // 4.修正子类constructor
        // var __pro = Object.create(Car.prototype);
        // __pro.constructor = BWM;
        //  BWM.prototype = __pro;
        // var m = new BWM('bule');
        // console.log(m);
        // console.log(m.sail());

        // 函数提升
        // (function(){
        //     var a = 20;
        //     var b = c = a;
        // })();
        // alert(c);

        // function test(){
        //     this.a = 20;
        // }
        // test.prototype.a = 30;
        // var q = new test();
        // alert(q.a);
        // var user = {
        //     age:20,
        //     init:function(){
        //         console.log(this.age);
        //     }
        // }
        // var data = {age:40};
        // var s = user.init.bind(data);
        // s();

        // function test(m){
        //     m.v = 20;
        // }
        // var m = {age:30};
        // test(m);
        // alert(m.v);
        var list_li = document.getElementsByTagName("li");
        for(var i=0; i< list_li.length; i++){
            list_li[i].onclick = function(){
                console.log(i);
            }
        }
    </script>
</body>

</html>